{"version":3,"sources":["cirrus.es5.min.js","util.js","autocomplete.js","dropdown.js","file-upload.js","header-navigation.js","header-overflow-menu.js","input-method.js","modal.js","overflow.js","scroll.js","tables.js","tabs.js"],"names":["util","initOnReady","f","document","readyState","addEventListener","acitem","aclist","acselected","acvisible","forEach","Array","prototype","show","select","init","selectItem","list","newitem","items","querySelectorAll","selected","querySelector","ix","indexOf","call","classList","contains","item","toggle","scrolly","getBoundingClientRect","top","cassie","scroll","scrollTop","offsetHeight","applyItem","input","value","textContent","innerText","blur","filterList","matcher","RegExp","console","log","target","search","add","remove","previousElementSibling","e","keyCode","dditem","ddlist","ddselected","open","label","dropdown","innerHTML","parentElement","preventDefault","fufield","field","control","files","length","split","pop","navbutton","button","parentNode","oflist","ofopen","stopPropagation","body","attr","lastInteraction","lastActive","activeElement","interact","type","setAttribute","moshow","momatch","key","mofocus","mopanel","mohide","visible","trigger","name","getAttribute","focus","setTimeout","panel","listitem","matches","documentElement","msMatchesSelector","children","element","selector","filter","child","obutton","isSameNode","nextFocus","relatedTarget","window","scroller","from","t0","Date","now","isbody","starttop","undefined","ambit","innerHeight","clientHeight","endtop","Math","min","max","scrollHeight","maxspeed","sign","acceltime","distance","cruisingdistance","duration","sqrt","track","dt","scrollto","newtop","animate","clearInterval","setInterval","scelement","pending","runpending","apply","fragment","match","destination","bind","scrollY","onscroll","tbrow","row","tablink","tabilink","tabitem","tabtabs","tabdrop","tabidrop","tabpanel","tabmatch","tabpanels","webkitMatchesSelector","mozMatchesSelector","oMatchesSelector","ancestor","selectTab","selectLink","tabs","selectPanel","panels","link"],"mappings":"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","file":"../js/cirrus.es5.min.js","sourcesContent":["'use strict';\n\n(function () {\n  // Module to be shared by all components\n  var util = function () {\n\n    var util = {\n\n      // call function f for initializing a component\n      // init right away if the document is loaded\n      // or wait till DOMContentLoaded event is fired\n      initOnReady: function initOnReady(f) {\n        if (document.readyState === 'loading') {\n          document.addEventListener('DOMContentLoaded', function () {\n            f();\n          });\n        } else {\n          f();\n        }\n      }\n    };\n\n    return util;\n  }();\n\n  // autocomplete\n\n  (function () {\n    // To be supported for autocomplete, a text input element with class\n    // 'js-autocomplete' should be immediately followed (next element sibling)\n    // by a list with class 'list-autocomplete' which will be shown/hidden by\n    // having an 'is-visible' class added/removed as needed. Items in the list\n    // are descendants of the list with class 'list-autocomplete__item' and\n    // should raise click events when their text content is to become the new\n    // text input value.\n\n    var acitem = '.list-autocomplete__item',\n        aclist = '.js-autocomplete + .list-autocomplete',\n        acselected = '.list-autocomplete__item.is-visible.is-selected',\n        acvisible = '.list-autocomplete__item.is-visible',\n        forEach = Array.prototype.forEach,\n        show = 'is-visible',\n        select = 'is-selected';\n\n    var init = function init() {\n      var selectItem = function selectItem(list, newitem) {\n        if (newitem === -1 || newitem === +1) {\n          var items = list.querySelectorAll(acvisible),\n              selected = list.querySelector(acselected),\n              ix = Array.prototype.indexOf.call(items, selected) + newitem;\n\n          // if there wasn't a selected item, select the first item\n          // if 'ix' goes out of range, 'items[ix]' will be undefined (falsy)\n          newitem = items[selected ? ix : 0];\n        }\n        if (newitem && !newitem.classList.contains(select)) {\n          forEach.call(list.querySelectorAll(acitem), function (item) {\n            return item.classList.toggle(select, item == newitem);\n          });\n          var scrolly = newitem.getBoundingClientRect().top - list.getBoundingClientRect().top;\n          if (scrolly < 0) {\n            cassie.scroll(list, list.scrollTop + scrolly);\n          } else if (scrolly + newitem.offsetHeight > list.offsetHeight) {\n            cassie.scroll(list, list.scrollTop + scrolly + newitem.offsetHeight - list.offsetHeight);\n          }\n        }\n      };\n\n      var applyItem = function applyItem(item, input) {\n        var value = item && (item.textContent || item.innerText /* IE */);\n        if (value) {\n          input.value = value;\n          input.blur();\n        }\n      };\n\n      var filterList = function filterList(list, input) {\n        var matcher = new RegExp(input.value, 'i');\n        forEach.call(list.querySelectorAll(acitem), function (item) {\n          console.log(\"Hello there!!!\");\n          var value = item.textContent || item.target.innerText /*IE*/ || '';\n          if (value.search(matcher) >= 0) {\n            item.classList.add(show);\n          } else {\n            item.classList.remove(show, select);\n          }\n        });\n      };\n\n      forEach.call(document.querySelectorAll(aclist), function (list) {\n        console.log(\"Hello there!!!\");\n        var input = list.previousElementSibling;\n        input.addEventListener('focus', function (e) {\n          return list.classList.add(show);\n        });\n        input.addEventListener('blur', function (e) {\n          return list.classList.remove(show);\n        });\n        input.addEventListener('keydown', function (e) {\n          return e.keyCode == 38 && selectItem(list, -1) || e.keyCode == 40 && selectItem(list, +1) || e.keyCode == 13 && applyItem(list.querySelector(acselected), input);\n        });\n        input.addEventListener('input', function (e) {\n          return filterList(list, input);\n        });\n        filterList(list, input);\n\n        forEach.call(list.querySelectorAll(acitem), function (item) {\n          item.addEventListener('mousemove', function (e) {\n            return selectItem(list, item);\n          });\n          item.addEventListener('click', function (e) {\n            return applyItem(item, input);\n          });\n        });\n      });\n    };\n\n    util.initOnReady(init);\n  })();\n\n  // dropdowns\n  (function () {\n\n    // To act as a drop-down, an element with class 'dropdown' should contain as\n    // an immediate child a text element with class 'js-dropdown' immediately\n    // followed (next element sibling) by a list with class 'dropdown__list'.\n    // The list will be shown/hidden by adding/removing an 'is-visible' class on\n    // the dropdown parent. Items in the list should have class 'dropdown__item'\n    // and should raise click events when their content is to become the new\n    // selected value.\n\n    var dditem = '.dropdown__item',\n        ddlist = '.dropdown > .js-dropdown + .dropdown__list',\n        ddselected = '.dropdown__item.is-selected',\n        forEach = Array.prototype.forEach,\n        open = 'is-open',\n        select = 'is-selected';\n\n    var init = function init() {\n      var selectItem = function selectItem(list, newitem) {\n        if (newitem === -1 || newitem === +1) {\n          var items = list.querySelectorAll(dditem),\n              selected = list.querySelector(ddselected),\n              ix = Array.prototype.indexOf.call(items, selected) + newitem;\n\n          // if there wasn't a selected item, select the first item\n          // if 'ix' goes out of range, 'items[ix]' will be undefined (falsy)\n          newitem = items[selected ? ix : 0];\n        }\n        if (newitem && !newitem.classList.contains(select)) {\n          forEach.call(list.querySelectorAll(dditem), function (item) {\n            return item.classList.toggle(select, item == newitem);\n          });\n          var scrolly = newitem.getBoundingClientRect().top - list.getBoundingClientRect().top;\n          if (scrolly < 0) {\n            cassie.scroll(list, list.scrollTop + scrolly);\n          } else if (scrolly + newitem.offsetHeight > list.offsetHeight) {\n            cassie.scroll(list, list.scrollTop + scrolly + newitem.offsetHeight - list.offsetHeight);\n          }\n        }\n      };\n\n      var applyItem = function applyItem(item, label, dropdown) {\n        label.innerHTML = item.innerHTML;\n      };\n\n      forEach.call(document.querySelectorAll(ddlist), function (list) {\n        var dropdown = list.parentElement,\n            label = list.previousElementSibling;\n        debugger;\n        dropdown.addEventListener('click', function (e) {\n          return dropdown.classList.toggle(open);\n        });\n        dropdown.addEventListener('blur', function (e) {\n          return dropdown.classList.remove(open);\n        });\n        dropdown.addEventListener('keydown', function (e) {\n          if (dropdown.classList.contains(open)) {\n            switch (e.keyCode) {\n              case 38:\n                // up arrow\n                selectItem(list, -1);\n                e.preventDefault();\n                break;\n              case 40:\n                // down arrow\n                selectItem(list, +1);\n                e.preventDefault();\n                break;\n              case 13: // enter\n              case 32:\n                // space\n                applyItem(list.querySelector(ddselected), label, dropdown);\n                dropdown.classList.remove(open);\n                e.preventDefault();\n                break;\n              case 27:\n                // escape\n                dropdown.classList.remove(open);\n                e.preventDefault();\n                break;\n            }\n          } else {\n            switch (e.keyCode) {\n              case 13: // enter\n              case 32:\n                // space\n                dropdown.classList.add(open);\n                e.preventDefault();\n                break;\n            }\n          }\n        });\n\n        forEach.call(list.querySelectorAll(dditem), function (item) {\n          item.addEventListener('mousemove', function (e) {\n            return selectItem(list, item);\n          });\n          item.addEventListener('click', function (e) {\n            return applyItem(item, label, dropdown);\n          });\n        });\n      });\n    };\n\n    util.initOnReady(init);\n  })();\n\n  // File Upload\n  (function () {\n\n    // To act as a file-upload summary field, a label element with class\n    // 'file-upload__field' should have its 'for' attribute point to the input\n    // element with a type of 'file'.\n\n    var fufield = '.file-upload__field';\n\n    var init = function init() {\n      Array.prototype.forEach.call(document.querySelectorAll(fufield), function (field) {\n        if (field.control) {\n          field.control.addEventListener('change', function (e) {\n            if (field.control.files && field.control.files.length > 1) {\n              field.innerHTML = field.control.files.length + ' files selected';\n            } else {\n              field.innerHTML = field.control.value && field.control.value.split('\\\\').pop();\n            }\n          });\n        }\n      });\n    };\n\n    util.initOnReady(init);\n  })();\n\n  // Global Header Nav Button\n  (function () {\n\n    var navbutton = '.js-nav-button',\n        open = 'is-open';\n\n    var init = function init() {\n      Array.prototype.forEach.call(document.querySelectorAll(navbutton), function (button) {\n        button.addEventListener('click', function () {\n          button.parentNode.classList.toggle(open);\n        });\n      });\n    };\n\n    util.initOnReady(init);\n  })();\n\n  // Header Overflow Menu\n  (function () {\n\n    var forEach = Array.prototype.forEach,\n        oflist = '.js-overflow-menu-button + .header-list',\n        open = 'is-open',\n        ofopen = '.js-overflow-menu-button + .header-list.is-open';\n\n    var init = function init() {\n      forEach.call(document.querySelectorAll(oflist), function (list) {\n        var button = list.previousElementSibling;\n        button.addEventListener('click', function (e) {\n          list.classList.toggle(open);\n          e.stopPropagation();\n        });\n      });\n\n      document.body.addEventListener('click', function (e) {\n        return forEach.call(document.querySelectorAll(ofopen), function (list) {\n          return list.classList.remove(open);\n        });\n      });\n    };\n\n    util.initOnReady(init);\n  })();\n\n  (function () {\n\n    // An attribute 'data-peripheral' is added to the body tag to indicate\n    // whether the last focus event resulted from a keyboard, mouse, or touch\n    // interaction. This can be used by controls that, for example, only wish\n    // to display focus highlighting when the last focus transition was\n    // keyboard-initiated (eg checkboxes, radio buttons, etc)\n\n    var attr = 'data-peripheral',\n        body = document.body;\n\n    var init = function init() {\n      var lastInteraction = 'none',\n          lastActive = document.activeElement,\n          interact = function interact(type) {\n        return lastInteraction = type;\n      };\n\n      document.body.setAttribute(attr, 'none');\n      document.body.addEventListener('mousedown', function () {\n        return interact('mouse');\n      }, true);\n      document.body.addEventListener('pointerdown', function () {\n        return interact('mouse');\n      }, true);\n      document.body.addEventListener('touchstart', function () {\n        return interact('touch');\n      }, true);\n      document.body.addEventListener('keydown', function () {\n        return interact('keyboard');\n      }, true);\n\n      document.body.addEventListener('focus', function () {\n        if (document.activeElement !== lastActive) {\n          // only update attribute on actual focus changes\n          body.setAttribute(attr, lastInteraction);\n          lastActive = document.activeElement;\n        }\n      }, true);\n    };\n\n    util.initOnReady(init);\n  })();\n\n  // Modal\n  (function () {\n\n    // An element with class 'js-modal' and an attribute 'data-modal-target'\n    // will display the corresponding modal panel (an element with an attribute\n    // 'data-modal' whose value matches the modal-target value of the clicked\n    // element) by adding an 'is-visible' class to the element. Focus will be\n    // placed on an element within the panel that has a 'js-modal-focus' class.\n    // When a modal is showing, a click on any element within that modal that\n    // has the class 'js-close-modal' will cause the 'is-visible' class to be\n    // removed, as will an unhandled 'escape' keypress within the modal panel.\n\n    var forEach = Array.prototype.forEach,\n        moshow = '.js-modal[data-modal-target]',\n        momatch = function momatch(key) {\n      return '[data-modal=\"' + key + '\"]';\n    },\n        mofocus = '.js-modal-focus',\n        mopanel = '[data-modal]',\n        mohide = '.js-close-modal',\n        visible = 'is-visible';\n\n    var init = function init() {\n      forEach.call(document.querySelectorAll(moshow), function (trigger) {\n        var name = trigger.getAttribute('data-modal-target'),\n            target = document.querySelector(momatch(name)),\n            focus = target.querySelector(mofocus);\n        trigger.addEventListener('click', function (e) {\n          target.classList.add(visible);\n          e.stopPropagation();\n          trigger.blur();\n          setTimeout(function () {\n            (focus || target).focus();\n          }, 100);\n        });\n      });\n\n      forEach.call(document.querySelectorAll(mopanel), function (panel) {\n        panel.addEventListener('keydown', function (e) {\n          return e.keyCode == 27 && panel.classList.remove(visible);\n        });\n\n        forEach.call(panel.querySelectorAll(mohide), function (trigger) {\n          return trigger.addEventListener('click', function (e) {\n            panel.classList.toggle(visible);\n            e.stopPropagation();\n          });\n        });\n      });\n    };\n\n    util.initOnReady(init);\n  })();\n\n  // Overflow Menu\n  (function () {\n\n    // To be supported for overflow display, a button element with class\n    // 'js-overflow-button' should be immediately followed (next element\n    // sibling) by a list with class 'list-overflow' which will be\n    // shown/hidden by having an 'is-open' class added/removed as needed.\n\n    var forEach = Array.prototype.forEach,\n        oflist = '.js-overflow-button + .list-overflow',\n        open = 'is-open',\n        ofopen = '.js-overflow-button.is-open',\n        listitem = '.list-overflow__item',\n        matches = document.documentElement.matches || document.documentElement.msMatchesSelector;\n\n    var init = function init() {\n      var children = function children(element, selector) {\n        return Array.prototype.filter.call(element.children, function (child) {\n          return matches.call(child, selector);\n        });\n      };\n\n      forEach.call(document.querySelectorAll(oflist), function (list) {\n        var button = list.previousElementSibling;\n        button.addEventListener('click', function (e) {\n          button.classList.toggle(open);\n          e.stopPropagation();\n\n          // hide all other opened lists if there is any\n          forEach.call(document.querySelectorAll(ofopen), function (obutton) {\n            if (!obutton.isSameNode(button)) {\n              obutton.classList.remove(open);\n            }\n          });\n        });\n\n        // hide when user tabs away from the current menu\n        // this event supports >= FF 52\n        button.addEventListener('focusout', function (e) {\n          var nextFocus = e.relatedTarget;\n          //focus outside of the current list\n          if (!list.contains(nextFocus)) {\n            button.classList.remove(open);\n          }\n        });\n\n        // when user tabs into one of the list item,\n        // tabbing away from the list will close the current list\n        forEach.call(children(list, listitem), function (item) {\n          item.addEventListener('focusout', function (e) {\n            var nextFocus = e.relatedTarget;\n            if (!list.contains(nextFocus)) {\n              button.classList.remove(open);\n            }\n          });\n        });\n      });\n\n      document.body.addEventListener('click', function (e) {\n        return forEach.call(document.querySelectorAll(ofopen), function (button) {\n          return button.classList.remove(open);\n        });\n      });\n\n      document.body.addEventListener('keydown', function (e) {\n        return forEach.call(document.querySelectorAll(ofopen), function (button) {\n          switch (e.keyCode) {\n            case 27:\n              // escape\n              button.classList.remove(open);\n          }\n        });\n      });\n    };\n\n    util.initOnReady(init);\n  })();\n\n  // Scroll functions\n  (function () {\n\n    window.cassie = window.cassie || {};\n\n    var scroller = false;\n\n    // A global function to scroll an element to a new position, which is\n    // applied as the element's scrollTop so it can be a body scroll or an\n    // internal element scroll depending on the element supplied. An\n    // adaptive timing function based on viewport size is used. The scroll\n    // start can optionally be supplied, otherwise the current scroll is\n    // used as the start.\n\n    window.cassie.scroll = function (element, top, from) {\n      var t0 = Date.now(),\n          isbody = element === document.body,\n          starttop = from === undefined ? element.scrollTop || (isbody ? document.documentElement.scrollTop : 0) : from,\n          ambit = isbody ? window.innerHeight : element.clientHeight,\n          endtop = Math.min(Math.max(0, top), element.scrollHeight - ambit),\n\n\n      // maxspeed determines how fast the scroll will go (px/ms), and which way\n      maxspeed = window.innerHeight / 40 * Math.sign(endtop - starttop),\n\n\n      // acceltime is the duration in ms of the ease in/out\n      acceltime = 1000,\n          distance = endtop - starttop,\n          cruisingdistance = distance - maxspeed * acceltime,\n          duration = Math.sign(cruisingdistance) === Math.sign(maxspeed) ?\n      // if we'll reach maxspeed, two acceltimes plus linear travel between\n      2 * acceltime + cruisingdistance / maxspeed :\n      // otherwise we skip from quadratic accel to decel seamlessly\n      2 * Math.sqrt(distance * acceltime / maxspeed),\n          track = function track(dt) {\n        return dt < acceltime ?\n        // up to acceltime we accelerate quadratically\n        maxspeed * dt * dt / (2 * acceltime) :\n        // after acceltime we scroll linearly at maxspeed\n        maxspeed * acceltime / 2 + maxspeed * (dt - acceltime);\n      },\n          scrollto = function scrollto(newtop) {\n        element.scrollTop = newtop;\n        if (isbody) {\n          document.documentElement.scrollTop = newtop; // for FF\n        }\n      },\n          animate = function animate() {\n        var dt = Date.now() - t0;\n        if (dt >= duration) {\n          scrollto(endtop);\n          clearInterval(scroller);\n          scroller = false;\n        } else {\n          var newtop = dt < duration / 2 ? starttop + track(dt) : endtop - track(duration - dt);\n          scrollto(newtop);\n          if (!scroller) {\n            scroller = setInterval(animate, 10);\n          }\n        }\n      };\n\n      if (scroller) {\n        clearInterval(scroller);\n        scroller = false;\n      }\n\n      animate();\n    };\n\n    // An internal link (of the form href=\"#xxx\") with class 'js-scroll-to' will\n    // trigger a smooth scroll to bring the target to the top of the viewport\n    // (or as near as possible) when the link is triggered.\n\n    var scelement = '.js-scroll-to';\n\n    var pending = false,\n        runpending = function runpending() {\n      if (pending) {\n        pending.apply();\n        pending = false;\n      }\n    };\n\n    var init = function init() {\n      Array.prototype.forEach.call(document.querySelectorAll(scelement), function (element) {\n        return element.addEventListener('click', function (e) {\n          var fragment = element.getAttribute('href').match(/\\#.*/);\n          if (fragment) {\n            var destination = document.querySelector(fragment[0]);\n            if (destination) {\n              // the link click will probably trigger a scroll which will interfere\n              // with our smooth-scroll animation, so we store the animation as a\n              // pending task and trigger it when the link scroll comes in or after\n              // a short time (just in case).\n              pending = cassie.scroll.bind(window, document.body, window.scrollY + destination.getBoundingClientRect().top, document.body.scrollTop || document.documentElement.scrollTop);\n              setTimeout(runpending, 20);\n            }\n          }\n        });\n      });\n    };\n\n    window.onscroll = runpending;\n\n    util.initOnReady(init);\n  })();\n\n  // Data Tables\n  (function () {\n\n    // Any element with a 'data-table-row' attribute set on it will respond to\n    // clicks by toggling whether the class 'is-selected' is applied.\n\n    var tbrow = '[data-table-row]',\n        select = 'is-selected';\n\n    var init = function init() {\n      Array.prototype.forEach.call(document.querySelectorAll(tbrow), function (row) {\n        row.addEventListener('click', function () {\n          return row.classList.toggle(select);\n        });\n      });\n    };\n\n    util.initOnReady(init);\n  })();\n\n  // Tabs\n  (function () {\n\n    // To act as tabs, each tab should be a link with class 'tabs__link' placed\n    // within an element with class 'tabs__item'. The tabs should be grouped\n    // within an element with class 'tabs', along with an element with class\n    // 'tabs__dropdown' which will be used as a menu trigger when there is\n    // insufficient screen space to permanently display the tab row by adding\n    // or removing an 'is-open' class to the 'tabs' element as needed. Each link\n    // should have an attribute 'data-tab' whose value is a unique name for the\n    // tab. The corresponding content for each tab should be placed within an\n    // element with class 'tab-panels__panel'. The panels should be grouped as\n    // direct children of an element with class 'tab-panels'. Each panel should\n    // have an attribute 'data-tab-panel' whose value is the unique name for the\n    // tab which activates that panel. The tabs and the panels are each shown/hidden\n    // by having an 'is-selected' class added/removed as needed. Each tab link\n    // should raise a click event when that tab is to become the selected tab in\n    // the group. Each group of tabs operates independently from other groups.\n\n    var forEach = Array.prototype.forEach,\n        tablink = '.tabs .tabs__item .tabs__link',\n        tabilink = '.tabs__item .tabs__link',\n        tabitem = '.tabs__item',\n        tabtabs = '.tabs',\n        tabdrop = '.tabs .tabs__dropdown',\n        tabidrop = '.tabs__dropdown',\n        tabpanel = '.tab-panels__panel',\n        tabmatch = function tabmatch(key) {\n      return '.tab-panels > .tab-panels__panel[data-tab-panel=\"' + key + '\"]';\n    },\n        tabpanels = '.tab-panels',\n        select = 'is-selected',\n        open = 'is-open';\n\n    // Finds the nearest ancestor, starting with the element itself, that\n    // matches the supplied selector. Returns undefined if no match found.\n    var matches = document.documentElement.matches || document.documentElement.webkitMatchesSelector || document.documentElement.mozMatchesSelector || document.documentElement.oMatchesSelector || document.documentElement.msMatchesSelector;\n    var ancestor = function ancestor(element, selector) {\n      return element && (matches.call(element, selector) ? element : ancestor(element.parentElement, selector));\n    };\n\n    var children = function children(element, selector) {\n      return Array.prototype.filter.call(element.children, function (child) {\n        return matches.call(child, selector);\n      });\n    };\n\n    // Selects a tab and its corresponding panel\n    var selectTab = function selectTab(e, selectLink) {\n      if (e) {\n        e.preventDefault();\n      }\n\n      var name = selectLink.getAttribute('data-tab'),\n          selectItem = ancestor(selectLink, tabitem),\n          tabs = ancestor(selectItem, tabtabs),\n          selectPanel = document.querySelector(tabmatch(name)),\n          panels = ancestor(selectPanel, tabpanels);\n\n      forEach.call(tabs.querySelectorAll(tabilink), function (link) {\n        var item = ancestor(link, tabitem);\n        link.setAttribute('aria-selected', item == selectItem);\n        item.classList.toggle(select, item == selectItem);\n      });\n\n      forEach.call(tabs.querySelectorAll(tabidrop), function (dropdown) {\n        dropdown.innerHTML = selectLink.innerHTML;\n      });\n\n      tabs.classList.remove(open);\n\n      if (panels) {\n        forEach.call(children(panels, tabpanel), function (panel) {\n          panel.classList.toggle(select, panel == selectPanel);\n          panel.setAttribute('aria-hidden', panel !== selectPanel);\n        });\n      }\n    };\n\n    var init = function init() {\n      // Click on a tab link selects the tab, escape cancels dropdown if active\n      forEach.call(document.querySelectorAll(tablink), function (link) {\n        link.addEventListener('click', function (e) {\n          return selectTab(e, link);\n        });\n        link.addEventListener('keydown', function (e) {\n          if (e.keyCode === 27) {\n            ancestor(link, tabtabs).classList.remove(open);\n          }\n        });\n        if (ancestor(link, tabitem).classList.contains(select)) {\n          selectTab(null, link);\n        }\n      });\n\n      // Click on a dropdown element toggles open, escape cancels\n      forEach.call(document.querySelectorAll(tabdrop), function (dropdown) {\n        var panel = ancestor(dropdown, tabtabs);\n        dropdown.addEventListener('click', function (e) {\n          e.preventDefault();\n          panel.classList.toggle(open);\n        });\n        dropdown.addEventListener('keydown', function (e) {\n          if (e.keyCode === 27) {\n            panel.classList.remove(open);\n          }\n        });\n      });\n    };\n\n    util.initOnReady(init);\n  })();\n})();","// Module to be shared by all components\nconst util = (() => {\n\n  const util = {\n\n    // call function f for initializing a component\n    // init right away if the document is loaded\n    // or wait till DOMContentLoaded event is fired\n    initOnReady: function(f) {\n      if (document.readyState === 'loading') {\n        document.addEventListener('DOMContentLoaded', () => {\n          f();\n        });\n      } else {\n        f();\n      }\n    }\n  };\n\n  return util;\n\n})();\n","// autocomplete\n\n(() => {\n  // To be supported for autocomplete, a text input element with class\n  // 'js-autocomplete' should be immediately followed (next element sibling)\n  // by a list with class 'list-autocomplete' which will be shown/hidden by\n  // having an 'is-visible' class added/removed as needed. Items in the list\n  // are descendants of the list with class 'list-autocomplete__item' and\n  // should raise click events when their text content is to become the new\n  // text input value.\n\n  const acitem = '.list-autocomplete__item',\n        aclist = '.js-autocomplete + .list-autocomplete',\n        acselected = '.list-autocomplete__item.is-visible.is-selected',\n        acvisible = '.list-autocomplete__item.is-visible',\n        forEach = Array.prototype.forEach,\n        show = 'is-visible',\n        select = 'is-selected';\n\n  const init = () => {\n    let selectItem = (list, newitem) => {\n      if ((newitem === -1) || (newitem === +1)) {\n        let items = list.querySelectorAll(acvisible),\n          selected = list.querySelector(acselected),\n          ix = Array.prototype.indexOf.call(items, selected) + newitem;\n\n        // if there wasn't a selected item, select the first item\n        // if 'ix' goes out of range, 'items[ix]' will be undefined (falsy)\n        newitem = items[selected ? ix : 0];\n      }\n      if (newitem && !newitem.classList.contains(select)) {\n        forEach.call(list.querySelectorAll(acitem),\n                        item => item.classList.toggle(select, item == newitem));\n        let scrolly = newitem.getBoundingClientRect().top - list.getBoundingClientRect().top;\n        if (scrolly < 0) {\n          cassie.scroll(list, list.scrollTop + scrolly);\n        } else if (scrolly + newitem.offsetHeight > list.offsetHeight) {\n          cassie.scroll(list, list.scrollTop + scrolly + newitem.offsetHeight - list.offsetHeight);\n        }\n      }\n    };\n\n    let applyItem = (item, input) => {\n      let value = item && (item.textContent || item.innerText /* IE */);\n      if (value) {\n        input.value = value;\n        input.blur();\n      }\n    };\n\n    let filterList = (list, input) => {\n      let matcher = new RegExp(input.value, 'i');\n      forEach.call(list.querySelectorAll(acitem), item => {\n        console.log(\"Hello there!!!\");\n        let value = item.textContent || item.target.innerText /*IE*/ || '';\n        if (value.search(matcher) >= 0) {\n          item.classList.add(show);\n        } else {\n          item.classList.remove(show, select);\n        }\n      });\n    };\n\n    forEach.call(document.querySelectorAll(aclist), list => {\n      console.log(\"Hello there!!!\");\n      let input = list.previousElementSibling;\n      input.addEventListener('focus', e => list.classList.add(show));\n      input.addEventListener('blur', e => list.classList.remove(show));\n      input.addEventListener('keydown', e =>\n        ((e.keyCode == 38) && selectItem(list, -1)) ||\n        ((e.keyCode == 40) && selectItem(list, +1)) ||\n        ((e.keyCode == 13) && applyItem(list.querySelector(acselected), input)));\n      input.addEventListener('input', e => filterList(list, input));\n      filterList(list, input);\n\n      forEach.call(list.querySelectorAll(acitem), item => {\n        item.addEventListener('mousemove', e => selectItem(list, item));\n        item.addEventListener('click', e => applyItem(item, input));\n      });\n    });\n  };\n\n  util.initOnReady(init);\n\n})();\n","\n\n// dropdowns\n(() => {\n\n  // To act as a drop-down, an element with class 'dropdown' should contain as\n  // an immediate child a text element with class 'js-dropdown' immediately\n  // followed (next element sibling) by a list with class 'dropdown__list'.\n  // The list will be shown/hidden by adding/removing an 'is-visible' class on\n  // the dropdown parent. Items in the list should have class 'dropdown__item'\n  // and should raise click events when their content is to become the new\n  // selected value.\n\n  const dditem = '.dropdown__item',\n        ddlist = '.dropdown > .js-dropdown + .dropdown__list',\n        ddselected = '.dropdown__item.is-selected',\n        forEach = Array.prototype.forEach,\n        open = 'is-open',\n        select = 'is-selected';\n\n  const init = () => {\n    let selectItem = (list, newitem) => {\n      if ((newitem === -1) || (newitem === +1)) {\n        let items = list.querySelectorAll(dditem),\n          selected = list.querySelector(ddselected),\n          ix = Array.prototype.indexOf.call(items, selected) + newitem;\n\n        // if there wasn't a selected item, select the first item\n        // if 'ix' goes out of range, 'items[ix]' will be undefined (falsy)\n        newitem = items[selected ? ix : 0];\n      }\n      if (newitem && !newitem.classList.contains(select)) {\n        forEach.call(list.querySelectorAll(dditem),\n                        item => item.classList.toggle(select, item == newitem));\n        let scrolly = newitem.getBoundingClientRect().top - list.getBoundingClientRect().top;\n        if (scrolly < 0) {\n          cassie.scroll(list, list.scrollTop + scrolly);\n        } else if (scrolly + newitem.offsetHeight > list.offsetHeight) {\n          cassie.scroll(list, list.scrollTop + scrolly + newitem.offsetHeight - list.offsetHeight);\n        }\n      }\n    };\n\n    let applyItem = (item, label, dropdown) => {\n      label.innerHTML = item.innerHTML;\n    };\n\n    forEach.call(document.querySelectorAll(ddlist), list => {\n      let dropdown = list.parentElement,\n        label = list.previousElementSibling;\n        debugger;\n      dropdown.addEventListener('click', e => dropdown.classList.toggle(open));\n      dropdown.addEventListener('blur', e => dropdown.classList.remove(open));\n      dropdown.addEventListener('keydown', e => {\n        if (dropdown.classList.contains(open)) {\n          switch (e.keyCode) {\n            case 38:  // up arrow\n              selectItem(list, -1);\n              e.preventDefault();\n              break;\n            case 40:  // down arrow\n              selectItem(list, +1);\n              e.preventDefault();\n              break;\n            case 13:  // enter\n            case 32:  // space\n              applyItem(list.querySelector(ddselected), label, dropdown);\n              dropdown.classList.remove(open);\n              e.preventDefault();\n              break;\n            case 27:  // escape\n              dropdown.classList.remove(open);\n              e.preventDefault();\n              break;\n          }\n        } else {\n          switch (e.keyCode) {\n            case 13:  // enter\n            case 32:  // space\n              dropdown.classList.add(open);\n              e.preventDefault();\n              break;\n          }\n        }\n      });\n\n      forEach.call(list.querySelectorAll(dditem), item => {\n        item.addEventListener('mousemove', e => selectItem(list, item));\n        item.addEventListener('click', e => applyItem(item, label, dropdown));\n      });\n    });\n  };\n\n  util.initOnReady(init);\n\n})();\n","\n// File Upload\n(() => {\n\n  // To act as a file-upload summary field, a label element with class\n  // 'file-upload__field' should have its 'for' attribute point to the input\n  // element with a type of 'file'.\n\n  const fufield = '.file-upload__field';\n\n  const init = () => {\n    Array.prototype.forEach.call(document.querySelectorAll(fufield), field => {\n      if (field.control) {\n        field.control.addEventListener('change', e => {\n          if (field.control.files && (field.control.files.length > 1)) {\n            field.innerHTML = `${field.control.files.length} files selected`;\n          } else {\n            field.innerHTML = field.control.value &&\n                              field.control.value.split('\\\\').pop();\n          }\n        });\n      }\n    });\n  };\n\n  util.initOnReady(init);\n\n})();\n","// Global Header Nav Button\n(() => {\n\n  const navbutton = '.js-nav-button',\n        open = 'is-open';\n\n  const init = () => {\n    Array.prototype.forEach.call(document.querySelectorAll(navbutton), button => {\n      button.addEventListener('click', () => {\n        button.parentNode.classList.toggle(open);\n      });\n    });\n  };\n\n  util.initOnReady(init);\n\n})();\n","\n// Header Overflow Menu\n(() => {\n\n  const forEach = Array.prototype.forEach,\n        oflist = '.js-overflow-menu-button + .header-list',\n        open = 'is-open',\n        ofopen = '.js-overflow-menu-button + .header-list.is-open';\n\n  const init = () => {\n    forEach.call(document.querySelectorAll(oflist), list => {\n      let button = list.previousElementSibling;\n      button.addEventListener('click', e => {\n        list.classList.toggle(open);\n        e.stopPropagation();\n      });\n    });\n\n    document.body.addEventListener('click', e =>\n      forEach.call(document.querySelectorAll(ofopen), list =>\n        list.classList.remove(open)\n      )\n    );\n  };\n\n  util.initOnReady(init);\n\n})();\n","\n(() => {\n\n  // An attribute 'data-peripheral' is added to the body tag to indicate\n  // whether the last focus event resulted from a keyboard, mouse, or touch\n  // interaction. This can be used by controls that, for example, only wish\n  // to display focus highlighting when the last focus transition was\n  // keyboard-initiated (eg checkboxes, radio buttons, etc)\n\n  const attr = 'data-peripheral',\n        body = document.body;\n\n  const init = () => {\n    let lastInteraction = 'none',\n      lastActive = document.activeElement,\n      interact = (type) => (lastInteraction = type);\n\n    document.body.setAttribute(attr, 'none');\n    document.body.addEventListener('mousedown', () => interact('mouse'), true);\n    document.body.addEventListener('pointerdown', () => interact('mouse'), true);\n    document.body.addEventListener('touchstart', () => interact('touch'), true);\n    document.body.addEventListener('keydown', () => interact('keyboard'), true);\n\n    document.body.addEventListener('focus', () => {\n      if (document.activeElement !== lastActive) {\n        // only update attribute on actual focus changes\n        body.setAttribute(attr, lastInteraction);\n        lastActive = document.activeElement;\n      }\n    }, true);\n  };\n\n  util.initOnReady(init);\n\n})();\n","// Modal\n(() => {\n\n  // An element with class 'js-modal' and an attribute 'data-modal-target'\n  // will display the corresponding modal panel (an element with an attribute\n  // 'data-modal' whose value matches the modal-target value of the clicked\n  // element) by adding an 'is-visible' class to the element. Focus will be\n  // placed on an element within the panel that has a 'js-modal-focus' class.\n  // When a modal is showing, a click on any element within that modal that\n  // has the class 'js-close-modal' will cause the 'is-visible' class to be\n  // removed, as will an unhandled 'escape' keypress within the modal panel.\n\n  const forEach = Array.prototype.forEach,\n        moshow = '.js-modal[data-modal-target]',\n        momatch = key => `[data-modal=\"${key}\"]`,\n        mofocus = '.js-modal-focus',\n        mopanel = '[data-modal]',\n        mohide = '.js-close-modal',\n        visible = 'is-visible';\n\n  const init = () => {\n    forEach.call(document.querySelectorAll(moshow), trigger => {\n      let name = trigger.getAttribute('data-modal-target'),\n          target = document.querySelector(momatch(name)),\n          focus = target.querySelector(mofocus);\n      trigger.addEventListener('click', e => {\n        target.classList.add(visible);\n        e.stopPropagation();\n        trigger.blur();\n        setTimeout(function() { (focus || target).focus(); }, 100);\n      });\n    });\n\n    forEach.call(document.querySelectorAll(mopanel), panel => {\n      panel.addEventListener('keydown', e =>\n        ((e.keyCode == 27) && panel.classList.remove(visible)));\n\n      forEach.call(panel.querySelectorAll(mohide), trigger =>\n        trigger.addEventListener('click', e => {\n          panel.classList.toggle(visible);\n          e.stopPropagation();\n        })\n      );\n    });\n  };\n\n  util.initOnReady(init);\n\n})();\n","\n// Overflow Menu\n(() => {\n\n  // To be supported for overflow display, a button element with class\n  // 'js-overflow-button' should be immediately followed (next element\n  // sibling) by a list with class 'list-overflow' which will be\n  // shown/hidden by having an 'is-open' class added/removed as needed.\n\n  const forEach = Array.prototype.forEach,\n        oflist = '.js-overflow-button + .list-overflow',\n        open = 'is-open',\n        ofopen = '.js-overflow-button.is-open',\n        listitem = '.list-overflow__item',\n        matches = document.documentElement.matches ||\n                  document.documentElement.msMatchesSelector;\n\n  const init = () => {\n    let children = (element, selector) =>\n      Array.prototype.filter.call(element.children, child => matches.call(child, selector));\n\n    forEach.call(document.querySelectorAll(oflist), list => {\n      let button = list.previousElementSibling;\n      button.addEventListener('click', e => {\n        button.classList.toggle(open);\n        e.stopPropagation();\n\n        // hide all other opened lists if there is any\n        forEach.call(document.querySelectorAll(ofopen), obutton => {\n          if (!obutton.isSameNode(button)) {\n            obutton.classList.remove(open);\n          }\n        });\n      });\n\n      // hide when user tabs away from the current menu\n      // this event supports >= FF 52\n      button.addEventListener('focusout', e => {\n        let nextFocus = e.relatedTarget;\n        //focus outside of the current list\n        if (!list.contains(nextFocus)) {\n          button.classList.remove(open);\n        }\n      });\n\n      // when user tabs into one of the list item,\n      // tabbing away from the list will close the current list\n      forEach.call(children(list, listitem), item => {\n        item.addEventListener('focusout', e => {\n          let nextFocus = e.relatedTarget;\n          if (!list.contains(nextFocus)) {\n            button.classList.remove(open);\n          }\n        });\n      });\n    });\n\n    document.body.addEventListener('click', e =>\n      forEach.call(document.querySelectorAll(ofopen), button =>\n        button.classList.remove(open)\n      )\n    );\n\n    document.body.addEventListener('keydown', e =>\n      forEach.call(document.querySelectorAll(ofopen), button => {\n          switch (e.keyCode) {\n            case 27:  // escape\n              button.classList.remove(open);\n          }\n        }\n      )\n    );\n  };\n\n  util.initOnReady(init);\n\n})();\n","\n// Scroll functions\n(() => {\n\n  window.cassie = window.cassie || {};\n\n  let scroller = false;\n\n  // A global function to scroll an element to a new position, which is\n  // applied as the element's scrollTop so it can be a body scroll or an\n  // internal element scroll depending on the element supplied. An\n  // adaptive timing function based on viewport size is used. The scroll\n  // start can optionally be supplied, otherwise the current scroll is\n  // used as the start.\n\n  window.cassie.scroll = (element, top, from) => {\n    const t0 = Date.now(),\n      isbody = (element === document.body),\n      starttop = (from === undefined) ? (element.scrollTop || (isbody ? document.documentElement.scrollTop : 0)) : from,\n      ambit = isbody ? window.innerHeight : element.clientHeight,\n      endtop = Math.min(Math.max(0, top), element.scrollHeight - ambit),\n\n      // maxspeed determines how fast the scroll will go (px/ms), and which way\n      maxspeed = window.innerHeight / 40 * Math.sign(endtop - starttop),\n\n      // acceltime is the duration in ms of the ease in/out\n      acceltime = 1000,\n\n      distance = endtop - starttop,\n      cruisingdistance = distance - (maxspeed * acceltime),\n      duration = (Math.sign(cruisingdistance) === Math.sign(maxspeed)) ?\n        // if we'll reach maxspeed, two acceltimes plus linear travel between\n        (2 * acceltime) + (cruisingdistance / maxspeed) :\n        // otherwise we skip from quadratic accel to decel seamlessly\n        2 * Math.sqrt(distance * acceltime / maxspeed),\n\n      track = dt => (dt < acceltime) ?\n        // up to acceltime we accelerate quadratically\n        maxspeed * dt * dt / (2 * acceltime) :\n        // after acceltime we scroll linearly at maxspeed\n        (maxspeed * acceltime / 2) + (maxspeed * (dt - acceltime)),\n\n      scrollto = newtop => {\n        element.scrollTop = newtop;\n        if (isbody) {\n          document.documentElement.scrollTop = newtop;  // for FF\n        }\n      },\n\n      animate = () => {\n        let dt = Date.now() - t0;\n        if (dt >= duration) {\n          scrollto(endtop);\n          clearInterval(scroller);\n          scroller = false;\n        } else {\n          let newtop = (dt < duration / 2) ?\n            starttop + track(dt) :\n            endtop - track(duration - dt);\n          scrollto(newtop);\n          if (!scroller) {\n            scroller = setInterval(animate, 10);\n          }\n        }\n      };\n\n      if (scroller) {\n        clearInterval(scroller);\n        scroller = false;\n      }\n\n      animate();\n  };\n\n  // An internal link (of the form href=\"#xxx\") with class 'js-scroll-to' will\n  // trigger a smooth scroll to bring the target to the top of the viewport\n  // (or as near as possible) when the link is triggered.\n\n  const scelement = '.js-scroll-to';\n\n  let pending = false,\n    runpending = () => {\n      if (pending) {\n        pending.apply();\n        pending = false;\n      }\n    };\n\n  const init = () => {\n    Array.prototype.forEach.call(document.querySelectorAll(scelement), element =>\n      element.addEventListener('click', e => {\n        let fragment = element.getAttribute('href').match(/\\#.*/);\n        if (fragment) {\n          let destination = document.querySelector(fragment[0]);\n          if (destination) {\n            // the link click will probably trigger a scroll which will interfere\n            // with our smooth-scroll animation, so we store the animation as a\n            // pending task and trigger it when the link scroll comes in or after\n            // a short time (just in case).\n            pending = cassie.scroll.bind(window,\n                                         document.body,\n                                         window.scrollY + destination.getBoundingClientRect().top,\n                                         document.body.scrollTop || document.documentElement.scrollTop);\n            setTimeout(runpending, 20);\n          }\n        }\n      })\n    );\n  };\n\n  window.onscroll = runpending;\n\n  util.initOnReady(init);\n\n})();\n","\n// Data Tables\n(() => {\n\n  // Any element with a 'data-table-row' attribute set on it will respond to\n  // clicks by toggling whether the class 'is-selected' is applied.\n\n  const tbrow = '[data-table-row]',\n        select = 'is-selected';\n\n  const init = () => {\n    Array.prototype.forEach.call(document.querySelectorAll(tbrow), row => {\n      row.addEventListener('click', () =>\n        row.classList.toggle(select)\n      );\n    });\n  };\n\n  util.initOnReady(init);\n\n})();\n","\n// Tabs\n(() => {\n\n  // To act as tabs, each tab should be a link with class 'tabs__link' placed\n  // within an element with class 'tabs__item'. The tabs should be grouped\n  // within an element with class 'tabs', along with an element with class\n  // 'tabs__dropdown' which will be used as a menu trigger when there is\n  // insufficient screen space to permanently display the tab row by adding\n  // or removing an 'is-open' class to the 'tabs' element as needed. Each link\n  // should have an attribute 'data-tab' whose value is a unique name for the\n  // tab. The corresponding content for each tab should be placed within an\n  // element with class 'tab-panels__panel'. The panels should be grouped as\n  // direct children of an element with class 'tab-panels'. Each panel should\n  // have an attribute 'data-tab-panel' whose value is the unique name for the\n  // tab which activates that panel. The tabs and the panels are each shown/hidden\n  // by having an 'is-selected' class added/removed as needed. Each tab link\n  // should raise a click event when that tab is to become the selected tab in\n  // the group. Each group of tabs operates independently from other groups.\n\n  const forEach = Array.prototype.forEach,\n        tablink = '.tabs .tabs__item .tabs__link',\n        tabilink = '.tabs__item .tabs__link',\n        tabitem = '.tabs__item',\n        tabtabs = '.tabs',\n        tabdrop = '.tabs .tabs__dropdown',\n        tabidrop = '.tabs__dropdown',\n        tabpanel = '.tab-panels__panel',\n        tabmatch = key => `.tab-panels > .tab-panels__panel[data-tab-panel=\"${key}\"]`,\n        tabpanels = '.tab-panels',\n        select = 'is-selected',\n        open = 'is-open';\n\n  // Finds the nearest ancestor, starting with the element itself, that\n  // matches the supplied selector. Returns undefined if no match found.\n  const matches = document.documentElement.matches ||\n                  document.documentElement.webkitMatchesSelector ||\n                  document.documentElement.mozMatchesSelector ||\n                  document.documentElement.oMatchesSelector ||\n                  document.documentElement.msMatchesSelector;\n  let ancestor = (element, selector) =>\n    element &&\n    (matches.call(element, selector) ?\n      element : ancestor(element.parentElement, selector));\n\n  let children = (element, selector) =>\n    Array.prototype.filter.call(element.children, child => matches.call(child, selector));\n\n  // Selects a tab and its corresponding panel\n  let selectTab = (e, selectLink) => {\n    if (e) { e.preventDefault(); }\n\n    let name = selectLink.getAttribute('data-tab'),\n      selectItem = ancestor(selectLink, tabitem),\n      tabs = ancestor(selectItem, tabtabs),\n      selectPanel = document.querySelector(tabmatch(name)),\n      panels = ancestor(selectPanel, tabpanels);\n\n    forEach.call(tabs.querySelectorAll(tabilink), link => {\n      let item = ancestor(link, tabitem);\n      link.setAttribute('aria-selected', item == selectItem);\n      item.classList.toggle(select, item == selectItem);\n    });\n\n    forEach.call(tabs.querySelectorAll(tabidrop), dropdown => {\n      dropdown.innerHTML = selectLink.innerHTML;\n    });\n\n    tabs.classList.remove(open);\n\n    if (panels) {\n      forEach.call(children(panels, tabpanel), panel => {\n        panel.classList.toggle(select, panel == selectPanel);\n        panel.setAttribute('aria-hidden', panel !== selectPanel);\n      });\n    }\n  };\n\n  const init = () => {\n    // Click on a tab link selects the tab, escape cancels dropdown if active\n    forEach.call(document.querySelectorAll(tablink), link => {\n      link.addEventListener('click', e => selectTab(e, link));\n      link.addEventListener('keydown', e => {\n        if (e.keyCode === 27) {\n          ancestor(link, tabtabs).classList.remove(open);\n        }\n      });\n      if (ancestor(link, tabitem).classList.contains(select)) {\n        selectTab(null, link);\n      }\n    });\n\n    // Click on a dropdown element toggles open, escape cancels\n    forEach.call(document.querySelectorAll(tabdrop), dropdown => {\n      let panel = ancestor(dropdown, tabtabs);\n      dropdown.addEventListener('click', e => {\n        e.preventDefault();\n        panel.classList.toggle(open);\n      });\n      dropdown.addEventListener('keydown', e => {\n        if (e.keyCode === 27) {\n          panel.classList.remove(open);\n        }\n      });\n    });\n  };\n\n  util.initOnReady(init);\n\n})();\n"]}