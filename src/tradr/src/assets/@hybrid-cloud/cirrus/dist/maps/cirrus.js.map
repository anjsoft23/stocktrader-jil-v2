{"version":3,"sources":["util.js","autocomplete.js","dropdown.js","file-upload.js","header-navigation.js","header-overflow-menu.js","input-method.js","modal.js","overflow.js","scroll.js","tables.js","tabs.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"../js/cirrus.js","sourcesContent":["// Module to be shared by all components\nconst util = (() => {\n\n  const util = {\n\n    // call function f for initializing a component\n    // init right away if the document is loaded\n    // or wait till DOMContentLoaded event is fired\n    initOnReady: function(f) {\n      if (document.readyState === 'loading') {\n        document.addEventListener('DOMContentLoaded', () => {\n          f();\n        });\n      } else {\n        f();\n      }\n    }\n  };\n\n  return util;\n\n})();\n","// autocomplete\n\n(() => {\n  // To be supported for autocomplete, a text input element with class\n  // 'js-autocomplete' should be immediately followed (next element sibling)\n  // by a list with class 'list-autocomplete' which will be shown/hidden by\n  // having an 'is-visible' class added/removed as needed. Items in the list\n  // are descendants of the list with class 'list-autocomplete__item' and\n  // should raise click events when their text content is to become the new\n  // text input value.\n\n  const acitem = '.list-autocomplete__item',\n        aclist = '.js-autocomplete + .list-autocomplete',\n        acselected = '.list-autocomplete__item.is-visible.is-selected',\n        acvisible = '.list-autocomplete__item.is-visible',\n        forEach = Array.prototype.forEach,\n        show = 'is-visible',\n        select = 'is-selected';\n\n  const init = () => {\n    let selectItem = (list, newitem) => {\n      if ((newitem === -1) || (newitem === +1)) {\n        let items = list.querySelectorAll(acvisible),\n          selected = list.querySelector(acselected),\n          ix = Array.prototype.indexOf.call(items, selected) + newitem;\n\n        // if there wasn't a selected item, select the first item\n        // if 'ix' goes out of range, 'items[ix]' will be undefined (falsy)\n        newitem = items[selected ? ix : 0];\n      }\n      if (newitem && !newitem.classList.contains(select)) {\n        forEach.call(list.querySelectorAll(acitem),\n                        item => item.classList.toggle(select, item == newitem));\n        let scrolly = newitem.getBoundingClientRect().top - list.getBoundingClientRect().top;\n        if (scrolly < 0) {\n          cassie.scroll(list, list.scrollTop + scrolly);\n        } else if (scrolly + newitem.offsetHeight > list.offsetHeight) {\n          cassie.scroll(list, list.scrollTop + scrolly + newitem.offsetHeight - list.offsetHeight);\n        }\n      }\n    };\n\n    let applyItem = (item, input) => {\n      let value = item && (item.textContent || item.innerText /* IE */);\n      if (value) {\n        input.value = value;\n        input.blur();\n      }\n    };\n\n    let filterList = (list, input) => {\n      let matcher = new RegExp(input.value, 'i');\n      forEach.call(list.querySelectorAll(acitem), item => {\n        console.log(\"Hello there!!!\");\n        let value = item.textContent || item.target.innerText /*IE*/ || '';\n        if (value.search(matcher) >= 0) {\n          item.classList.add(show);\n        } else {\n          item.classList.remove(show, select);\n        }\n      });\n    };\n\n    forEach.call(document.querySelectorAll(aclist), list => {\n      console.log(\"Hello there!!!\");\n      let input = list.previousElementSibling;\n      input.addEventListener('focus', e => list.classList.add(show));\n      input.addEventListener('blur', e => list.classList.remove(show));\n      input.addEventListener('keydown', e =>\n        ((e.keyCode == 38) && selectItem(list, -1)) ||\n        ((e.keyCode == 40) && selectItem(list, +1)) ||\n        ((e.keyCode == 13) && applyItem(list.querySelector(acselected), input)));\n      input.addEventListener('input', e => filterList(list, input));\n      filterList(list, input);\n\n      forEach.call(list.querySelectorAll(acitem), item => {\n        item.addEventListener('mousemove', e => selectItem(list, item));\n        item.addEventListener('click', e => applyItem(item, input));\n      });\n    });\n  };\n\n  util.initOnReady(init);\n\n})();\n","\n\n// dropdowns\n(() => {\n\n  // To act as a drop-down, an element with class 'dropdown' should contain as\n  // an immediate child a text element with class 'js-dropdown' immediately\n  // followed (next element sibling) by a list with class 'dropdown__list'.\n  // The list will be shown/hidden by adding/removing an 'is-visible' class on\n  // the dropdown parent. Items in the list should have class 'dropdown__item'\n  // and should raise click events when their content is to become the new\n  // selected value.\n\n  const dditem = '.dropdown__item',\n        ddlist = '.dropdown > .js-dropdown + .dropdown__list',\n        ddselected = '.dropdown__item.is-selected',\n        forEach = Array.prototype.forEach,\n        open = 'is-open',\n        select = 'is-selected';\n\n  const init = () => {\n    let selectItem = (list, newitem) => {\n      if ((newitem === -1) || (newitem === +1)) {\n        let items = list.querySelectorAll(dditem),\n          selected = list.querySelector(ddselected),\n          ix = Array.prototype.indexOf.call(items, selected) + newitem;\n\n        // if there wasn't a selected item, select the first item\n        // if 'ix' goes out of range, 'items[ix]' will be undefined (falsy)\n        newitem = items[selected ? ix : 0];\n      }\n      if (newitem && !newitem.classList.contains(select)) {\n        forEach.call(list.querySelectorAll(dditem),\n                        item => item.classList.toggle(select, item == newitem));\n        let scrolly = newitem.getBoundingClientRect().top - list.getBoundingClientRect().top;\n        if (scrolly < 0) {\n          cassie.scroll(list, list.scrollTop + scrolly);\n        } else if (scrolly + newitem.offsetHeight > list.offsetHeight) {\n          cassie.scroll(list, list.scrollTop + scrolly + newitem.offsetHeight - list.offsetHeight);\n        }\n      }\n    };\n\n    let applyItem = (item, label, dropdown) => {\n      label.innerHTML = item.innerHTML;\n    };\n\n    forEach.call(document.querySelectorAll(ddlist), list => {\n      let dropdown = list.parentElement,\n        label = list.previousElementSibling;\n        debugger;\n      dropdown.addEventListener('click', e => dropdown.classList.toggle(open));\n      dropdown.addEventListener('blur', e => dropdown.classList.remove(open));\n      dropdown.addEventListener('keydown', e => {\n        if (dropdown.classList.contains(open)) {\n          switch (e.keyCode) {\n            case 38:  // up arrow\n              selectItem(list, -1);\n              e.preventDefault();\n              break;\n            case 40:  // down arrow\n              selectItem(list, +1);\n              e.preventDefault();\n              break;\n            case 13:  // enter\n            case 32:  // space\n              applyItem(list.querySelector(ddselected), label, dropdown);\n              dropdown.classList.remove(open);\n              e.preventDefault();\n              break;\n            case 27:  // escape\n              dropdown.classList.remove(open);\n              e.preventDefault();\n              break;\n          }\n        } else {\n          switch (e.keyCode) {\n            case 13:  // enter\n            case 32:  // space\n              dropdown.classList.add(open);\n              e.preventDefault();\n              break;\n          }\n        }\n      });\n\n      forEach.call(list.querySelectorAll(dditem), item => {\n        item.addEventListener('mousemove', e => selectItem(list, item));\n        item.addEventListener('click', e => applyItem(item, label, dropdown));\n      });\n    });\n  };\n\n  util.initOnReady(init);\n\n})();\n","\n// File Upload\n(() => {\n\n  // To act as a file-upload summary field, a label element with class\n  // 'file-upload__field' should have its 'for' attribute point to the input\n  // element with a type of 'file'.\n\n  const fufield = '.file-upload__field';\n\n  const init = () => {\n    Array.prototype.forEach.call(document.querySelectorAll(fufield), field => {\n      if (field.control) {\n        field.control.addEventListener('change', e => {\n          if (field.control.files && (field.control.files.length > 1)) {\n            field.innerHTML = `${field.control.files.length} files selected`;\n          } else {\n            field.innerHTML = field.control.value &&\n                              field.control.value.split('\\\\').pop();\n          }\n        });\n      }\n    });\n  };\n\n  util.initOnReady(init);\n\n})();\n","// Global Header Nav Button\n(() => {\n\n  const navbutton = '.js-nav-button',\n        open = 'is-open';\n\n  const init = () => {\n    Array.prototype.forEach.call(document.querySelectorAll(navbutton), button => {\n      button.addEventListener('click', () => {\n        button.parentNode.classList.toggle(open);\n      });\n    });\n  };\n\n  util.initOnReady(init);\n\n})();\n","\n// Header Overflow Menu\n(() => {\n\n  const forEach = Array.prototype.forEach,\n        oflist = '.js-overflow-menu-button + .header-list',\n        open = 'is-open',\n        ofopen = '.js-overflow-menu-button + .header-list.is-open';\n\n  const init = () => {\n    forEach.call(document.querySelectorAll(oflist), list => {\n      let button = list.previousElementSibling;\n      button.addEventListener('click', e => {\n        list.classList.toggle(open);\n        e.stopPropagation();\n      });\n    });\n\n    document.body.addEventListener('click', e =>\n      forEach.call(document.querySelectorAll(ofopen), list =>\n        list.classList.remove(open)\n      )\n    );\n  };\n\n  util.initOnReady(init);\n\n})();\n","\n(() => {\n\n  // An attribute 'data-peripheral' is added to the body tag to indicate\n  // whether the last focus event resulted from a keyboard, mouse, or touch\n  // interaction. This can be used by controls that, for example, only wish\n  // to display focus highlighting when the last focus transition was\n  // keyboard-initiated (eg checkboxes, radio buttons, etc)\n\n  const attr = 'data-peripheral',\n        body = document.body;\n\n  const init = () => {\n    let lastInteraction = 'none',\n      lastActive = document.activeElement,\n      interact = (type) => (lastInteraction = type);\n\n    document.body.setAttribute(attr, 'none');\n    document.body.addEventListener('mousedown', () => interact('mouse'), true);\n    document.body.addEventListener('pointerdown', () => interact('mouse'), true);\n    document.body.addEventListener('touchstart', () => interact('touch'), true);\n    document.body.addEventListener('keydown', () => interact('keyboard'), true);\n\n    document.body.addEventListener('focus', () => {\n      if (document.activeElement !== lastActive) {\n        // only update attribute on actual focus changes\n        body.setAttribute(attr, lastInteraction);\n        lastActive = document.activeElement;\n      }\n    }, true);\n  };\n\n  util.initOnReady(init);\n\n})();\n","// Modal\n(() => {\n\n  // An element with class 'js-modal' and an attribute 'data-modal-target'\n  // will display the corresponding modal panel (an element with an attribute\n  // 'data-modal' whose value matches the modal-target value of the clicked\n  // element) by adding an 'is-visible' class to the element. Focus will be\n  // placed on an element within the panel that has a 'js-modal-focus' class.\n  // When a modal is showing, a click on any element within that modal that\n  // has the class 'js-close-modal' will cause the 'is-visible' class to be\n  // removed, as will an unhandled 'escape' keypress within the modal panel.\n\n  const forEach = Array.prototype.forEach,\n        moshow = '.js-modal[data-modal-target]',\n        momatch = key => `[data-modal=\"${key}\"]`,\n        mofocus = '.js-modal-focus',\n        mopanel = '[data-modal]',\n        mohide = '.js-close-modal',\n        visible = 'is-visible';\n\n  const init = () => {\n    forEach.call(document.querySelectorAll(moshow), trigger => {\n      let name = trigger.getAttribute('data-modal-target'),\n          target = document.querySelector(momatch(name)),\n          focus = target.querySelector(mofocus);\n      trigger.addEventListener('click', e => {\n        target.classList.add(visible);\n        e.stopPropagation();\n        trigger.blur();\n        setTimeout(function() { (focus || target).focus(); }, 100);\n      });\n    });\n\n    forEach.call(document.querySelectorAll(mopanel), panel => {\n      panel.addEventListener('keydown', e =>\n        ((e.keyCode == 27) && panel.classList.remove(visible)));\n\n      forEach.call(panel.querySelectorAll(mohide), trigger =>\n        trigger.addEventListener('click', e => {\n          panel.classList.toggle(visible);\n          e.stopPropagation();\n        })\n      );\n    });\n  };\n\n  util.initOnReady(init);\n\n})();\n","\n// Overflow Menu\n(() => {\n\n  // To be supported for overflow display, a button element with class\n  // 'js-overflow-button' should be immediately followed (next element\n  // sibling) by a list with class 'list-overflow' which will be\n  // shown/hidden by having an 'is-open' class added/removed as needed.\n\n  const forEach = Array.prototype.forEach,\n        oflist = '.js-overflow-button + .list-overflow',\n        open = 'is-open',\n        ofopen = '.js-overflow-button.is-open',\n        listitem = '.list-overflow__item',\n        matches = document.documentElement.matches ||\n                  document.documentElement.msMatchesSelector;\n\n  const init = () => {\n    let children = (element, selector) =>\n      Array.prototype.filter.call(element.children, child => matches.call(child, selector));\n\n    forEach.call(document.querySelectorAll(oflist), list => {\n      let button = list.previousElementSibling;\n      button.addEventListener('click', e => {\n        button.classList.toggle(open);\n        e.stopPropagation();\n\n        // hide all other opened lists if there is any\n        forEach.call(document.querySelectorAll(ofopen), obutton => {\n          if (!obutton.isSameNode(button)) {\n            obutton.classList.remove(open);\n          }\n        });\n      });\n\n      // hide when user tabs away from the current menu\n      // this event supports >= FF 52\n      button.addEventListener('focusout', e => {\n        let nextFocus = e.relatedTarget;\n        //focus outside of the current list\n        if (!list.contains(nextFocus)) {\n          button.classList.remove(open);\n        }\n      });\n\n      // when user tabs into one of the list item,\n      // tabbing away from the list will close the current list\n      forEach.call(children(list, listitem), item => {\n        item.addEventListener('focusout', e => {\n          let nextFocus = e.relatedTarget;\n          if (!list.contains(nextFocus)) {\n            button.classList.remove(open);\n          }\n        });\n      });\n    });\n\n    document.body.addEventListener('click', e =>\n      forEach.call(document.querySelectorAll(ofopen), button =>\n        button.classList.remove(open)\n      )\n    );\n\n    document.body.addEventListener('keydown', e =>\n      forEach.call(document.querySelectorAll(ofopen), button => {\n          switch (e.keyCode) {\n            case 27:  // escape\n              button.classList.remove(open);\n          }\n        }\n      )\n    );\n  };\n\n  util.initOnReady(init);\n\n})();\n","\n// Scroll functions\n(() => {\n\n  window.cassie = window.cassie || {};\n\n  let scroller = false;\n\n  // A global function to scroll an element to a new position, which is\n  // applied as the element's scrollTop so it can be a body scroll or an\n  // internal element scroll depending on the element supplied. An\n  // adaptive timing function based on viewport size is used. The scroll\n  // start can optionally be supplied, otherwise the current scroll is\n  // used as the start.\n\n  window.cassie.scroll = (element, top, from) => {\n    const t0 = Date.now(),\n      isbody = (element === document.body),\n      starttop = (from === undefined) ? (element.scrollTop || (isbody ? document.documentElement.scrollTop : 0)) : from,\n      ambit = isbody ? window.innerHeight : element.clientHeight,\n      endtop = Math.min(Math.max(0, top), element.scrollHeight - ambit),\n\n      // maxspeed determines how fast the scroll will go (px/ms), and which way\n      maxspeed = window.innerHeight / 40 * Math.sign(endtop - starttop),\n\n      // acceltime is the duration in ms of the ease in/out\n      acceltime = 1000,\n\n      distance = endtop - starttop,\n      cruisingdistance = distance - (maxspeed * acceltime),\n      duration = (Math.sign(cruisingdistance) === Math.sign(maxspeed)) ?\n        // if we'll reach maxspeed, two acceltimes plus linear travel between\n        (2 * acceltime) + (cruisingdistance / maxspeed) :\n        // otherwise we skip from quadratic accel to decel seamlessly\n        2 * Math.sqrt(distance * acceltime / maxspeed),\n\n      track = dt => (dt < acceltime) ?\n        // up to acceltime we accelerate quadratically\n        maxspeed * dt * dt / (2 * acceltime) :\n        // after acceltime we scroll linearly at maxspeed\n        (maxspeed * acceltime / 2) + (maxspeed * (dt - acceltime)),\n\n      scrollto = newtop => {\n        element.scrollTop = newtop;\n        if (isbody) {\n          document.documentElement.scrollTop = newtop;  // for FF\n        }\n      },\n\n      animate = () => {\n        let dt = Date.now() - t0;\n        if (dt >= duration) {\n          scrollto(endtop);\n          clearInterval(scroller);\n          scroller = false;\n        } else {\n          let newtop = (dt < duration / 2) ?\n            starttop + track(dt) :\n            endtop - track(duration - dt);\n          scrollto(newtop);\n          if (!scroller) {\n            scroller = setInterval(animate, 10);\n          }\n        }\n      };\n\n      if (scroller) {\n        clearInterval(scroller);\n        scroller = false;\n      }\n\n      animate();\n  };\n\n  // An internal link (of the form href=\"#xxx\") with class 'js-scroll-to' will\n  // trigger a smooth scroll to bring the target to the top of the viewport\n  // (or as near as possible) when the link is triggered.\n\n  const scelement = '.js-scroll-to';\n\n  let pending = false,\n    runpending = () => {\n      if (pending) {\n        pending.apply();\n        pending = false;\n      }\n    };\n\n  const init = () => {\n    Array.prototype.forEach.call(document.querySelectorAll(scelement), element =>\n      element.addEventListener('click', e => {\n        let fragment = element.getAttribute('href').match(/\\#.*/);\n        if (fragment) {\n          let destination = document.querySelector(fragment[0]);\n          if (destination) {\n            // the link click will probably trigger a scroll which will interfere\n            // with our smooth-scroll animation, so we store the animation as a\n            // pending task and trigger it when the link scroll comes in or after\n            // a short time (just in case).\n            pending = cassie.scroll.bind(window,\n                                         document.body,\n                                         window.scrollY + destination.getBoundingClientRect().top,\n                                         document.body.scrollTop || document.documentElement.scrollTop);\n            setTimeout(runpending, 20);\n          }\n        }\n      })\n    );\n  };\n\n  window.onscroll = runpending;\n\n  util.initOnReady(init);\n\n})();\n","\n// Data Tables\n(() => {\n\n  // Any element with a 'data-table-row' attribute set on it will respond to\n  // clicks by toggling whether the class 'is-selected' is applied.\n\n  const tbrow = '[data-table-row]',\n        select = 'is-selected';\n\n  const init = () => {\n    Array.prototype.forEach.call(document.querySelectorAll(tbrow), row => {\n      row.addEventListener('click', () =>\n        row.classList.toggle(select)\n      );\n    });\n  };\n\n  util.initOnReady(init);\n\n})();\n","\n// Tabs\n(() => {\n\n  // To act as tabs, each tab should be a link with class 'tabs__link' placed\n  // within an element with class 'tabs__item'. The tabs should be grouped\n  // within an element with class 'tabs', along with an element with class\n  // 'tabs__dropdown' which will be used as a menu trigger when there is\n  // insufficient screen space to permanently display the tab row by adding\n  // or removing an 'is-open' class to the 'tabs' element as needed. Each link\n  // should have an attribute 'data-tab' whose value is a unique name for the\n  // tab. The corresponding content for each tab should be placed within an\n  // element with class 'tab-panels__panel'. The panels should be grouped as\n  // direct children of an element with class 'tab-panels'. Each panel should\n  // have an attribute 'data-tab-panel' whose value is the unique name for the\n  // tab which activates that panel. The tabs and the panels are each shown/hidden\n  // by having an 'is-selected' class added/removed as needed. Each tab link\n  // should raise a click event when that tab is to become the selected tab in\n  // the group. Each group of tabs operates independently from other groups.\n\n  const forEach = Array.prototype.forEach,\n        tablink = '.tabs .tabs__item .tabs__link',\n        tabilink = '.tabs__item .tabs__link',\n        tabitem = '.tabs__item',\n        tabtabs = '.tabs',\n        tabdrop = '.tabs .tabs__dropdown',\n        tabidrop = '.tabs__dropdown',\n        tabpanel = '.tab-panels__panel',\n        tabmatch = key => `.tab-panels > .tab-panels__panel[data-tab-panel=\"${key}\"]`,\n        tabpanels = '.tab-panels',\n        select = 'is-selected',\n        open = 'is-open';\n\n  // Finds the nearest ancestor, starting with the element itself, that\n  // matches the supplied selector. Returns undefined if no match found.\n  const matches = document.documentElement.matches ||\n                  document.documentElement.webkitMatchesSelector ||\n                  document.documentElement.mozMatchesSelector ||\n                  document.documentElement.oMatchesSelector ||\n                  document.documentElement.msMatchesSelector;\n  let ancestor = (element, selector) =>\n    element &&\n    (matches.call(element, selector) ?\n      element : ancestor(element.parentElement, selector));\n\n  let children = (element, selector) =>\n    Array.prototype.filter.call(element.children, child => matches.call(child, selector));\n\n  // Selects a tab and its corresponding panel\n  let selectTab = (e, selectLink) => {\n    if (e) { e.preventDefault(); }\n\n    let name = selectLink.getAttribute('data-tab'),\n      selectItem = ancestor(selectLink, tabitem),\n      tabs = ancestor(selectItem, tabtabs),\n      selectPanel = document.querySelector(tabmatch(name)),\n      panels = ancestor(selectPanel, tabpanels);\n\n    forEach.call(tabs.querySelectorAll(tabilink), link => {\n      let item = ancestor(link, tabitem);\n      link.setAttribute('aria-selected', item == selectItem);\n      item.classList.toggle(select, item == selectItem);\n    });\n\n    forEach.call(tabs.querySelectorAll(tabidrop), dropdown => {\n      dropdown.innerHTML = selectLink.innerHTML;\n    });\n\n    tabs.classList.remove(open);\n\n    if (panels) {\n      forEach.call(children(panels, tabpanel), panel => {\n        panel.classList.toggle(select, panel == selectPanel);\n        panel.setAttribute('aria-hidden', panel !== selectPanel);\n      });\n    }\n  };\n\n  const init = () => {\n    // Click on a tab link selects the tab, escape cancels dropdown if active\n    forEach.call(document.querySelectorAll(tablink), link => {\n      link.addEventListener('click', e => selectTab(e, link));\n      link.addEventListener('keydown', e => {\n        if (e.keyCode === 27) {\n          ancestor(link, tabtabs).classList.remove(open);\n        }\n      });\n      if (ancestor(link, tabitem).classList.contains(select)) {\n        selectTab(null, link);\n      }\n    });\n\n    // Click on a dropdown element toggles open, escape cancels\n    forEach.call(document.querySelectorAll(tabdrop), dropdown => {\n      let panel = ancestor(dropdown, tabtabs);\n      dropdown.addEventListener('click', e => {\n        e.preventDefault();\n        panel.classList.toggle(open);\n      });\n      dropdown.addEventListener('keydown', e => {\n        if (e.keyCode === 27) {\n          panel.classList.remove(open);\n        }\n      });\n    });\n  };\n\n  util.initOnReady(init);\n\n})();\n"]}